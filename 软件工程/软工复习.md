> ## 免责声明：
>
> 1. 此份整理是 **李浩然** 同志整理内容的 markdown 转，若文中有误，请直接联系前者
> 2. 整理是我的个人行为，查看是你的个人行为，若因本份整理的内容导致考试丢分，概不负责
> 3. 文档中的章节序号，与书本序号不严格相同

> ## 计科班大题内容：
>
> 1. 判定树
> 2. 环形复杂度
> 3. 数据流图
> 4. 状态转换图
> 5. 六个库表



# 第一章 软件工程概述



## 1.1 软件危机



### 1.1.1 软件危机概念

> **软件危机**是指在计算机软件的**开发和维护过程中**所遇到的一些列**严重问题**。

软件危机包含的方面：

- 如何**开发**软件，以满足对软件日益增长的需求
- 如何**维护**数量不断膨胀的已有软件



### 1.1.2 软件危机的典型表现

（至少记三点，wyf如是说）

- `成本和进度估算不准确`：对软件开发成本和进度的估计常常很不准确
- `用户不满意`：用户对已完成的软件系统不满意的现象经常发生
- `软件质量不佳`：软件产品的质量往往靠不住
- `不可维护`：软件常常是不可维护的
- `缺少文档`：软件通常没有适当的文档资料
- `软件成本占比的上升`：软件成本在计算机系统中总成本所占比的比例逐年上升
- `软件开发速率跟不上`：软件开发生产率提高的速度，远远跟不上计算机应用迅速普及深入的趋势。

​	

### 1.1.3 产生软件危机的原因

> 软件危机产生的原因，一方面与软件本身的特点有关，另一方面也和软件开发和维护的方法不正确有关。

软件本身的特点给开发和维护带来了客观困难：

- 软件是计算机系统中的逻辑部件，缺乏“可见性”
- 规模庞大，程序复杂

软件开发和维护过程中的错误认识和做法：

- 忽略需求分析，认为软件开发等于编写程序
- 轻视软件维护

​	

### 1.1.4 消除软件危机的途径

- 对计算机软件有一个正确的认识（软件≠程序）
- 必须充分认识到软件开发不是某种个体劳动的神秘技巧，而应该是一种组织良好、管理严密、各类人员协同配合、共同完成的工程项目
- 推广使用在实践中总结出来的开发软件的成功技术和方法
- 开发和使用更好的软件工具。



> 软件是程序、数据及相关文档的完整集合。

- 程序是能够完成预定功能和性能的可执行的指令序列
- 数据是使程序能够适当地处理信息的数据结构
- 文档是开发、使用和维护程序所需要的图文资料。





## 1.2 软件工程



### 1.2.1 软件工程的概念

概括：软件工程是指导计算机软件开发和维护的一门工程学科。

> 1993年IEEE的定义：软件工程是把系统的、规范的、可度量的途径应用于软件开发、运行和维护过程，也就是把工程应用于软件；研究前者提到的途径。



### 1.2.2 软件工程的本质特性

- 软件工程关注于大型程序的构造
- 软件工程的中心课题是控制复杂性
- 软件经常变化
- 开发软件的效率非常重要
- 和谐地合作是开发软件的关键
- 软件必须有效地支持它的用户
- 在软件工程领域中通常由具有一种文化背景的人替具有另一种文化背景的人创造产品。



### 1.2.3 软件工程的基本原理

- 用分阶段的生命周期计划严格管理
- 坚持进行阶段评审
- 实行严格的产品控制
- 采用现代程序设计技术
- 结果应能清楚地审查
- 开发小组的人员应该少而精
- 承认不断改进软件工程实践的必要性



### 1.2.4 软件工程方法学

> 软件工程方法学包含3个要素：方法、工具和过程。

- 方法是完成软件开发的各项任务的技术方法，回答“怎样做”的问题

- 工具是为运用方法而提供的自动的或半自动的软件工程支撑环境

- 过程是为了获得高质量的软件所需要完成的一系列任务的框架，它规定了完成各项任务的工作步骤。

目前使用的最广泛的软件方法工程学，分别是传统方法学和面向对象方法学。



#### 1.2.4.1 传统方法学

传统方法学：也称为生命周期方法学或结构化范型

优点：

- 把软件生命周期划分成基干个阶段，每个阶段的任务相对独立，而且比较简单，便于不同人员分工协作，从而降低了整个软件开发过程的困难程度。

缺点：

- 当软件规模庞大时，或者对软件的需求是模糊的或会承受时间而变化的时候，发开出的软件往往不成功；而且维护起来仍然很困难。

#### 1.2.4.2 面向对象方法学

优点：

- 降低了软件产品的复杂性；
- 提高了软件的可理解性；
- 简化了软件的开发和维护工作；
- 促进了软件重用。





## 1.3 软件生命周期



### 1.3.1 软件生命周期概念

> 软件生命周期由软件定义、软件开发和运行维护（也称为软件维护）3个时期组成。

软件定义划分为三个阶段：问题定义；可行性研究；需求分析。

软件开发划分为四个阶段：总体设计；详细设计；编码和单元测试；综合测试。

运行维护划分为一个阶段：软件维护





## 1.4 软件过程

> 软件过程是为了开发出高质量的软件产品所需完成的一系列任务的框架，它规定了完成各项任务的工作步骤。

|     模型     |                            特点                            |                             优点                             |                             缺点                             |
| :----------: | :--------------------------------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|   瀑布模型   | 阶段间具有顺序性和依赖性；推迟实现的观点；质量保证的观点。 | 它提供了一个模板，这个模板使得分析、设计、编码、测试和支持的方法可以在该模板下有一个共同的指导。虽然有不少缺陷但比在软件开发中随意的状态要好得多。 | 实际的项目大部分情况难以按照该模型给出的顺序进行，而且这种模型的迭代是间接的，这很容易由微小的变化而造成大的混乱。 |
| 快速原型模型 |                                                            | 使用户能够感受到实际的系统，使开发者能够快速地构造出系统的框架。 | 产品的先天性不足，因为开发者常常需要做实现上的折中，可能采用不合适的操作系统或程序设计语言，以使原型能够尽快工作。 |
|   增量模型   |                                                            | 人员分配灵活，刚开始不用投入大量人力资源，当核心产品很受欢迎时，可增加人力实现下一个增量；当配备的人员不能在设定的期限内完成产品时，它提供了一种先推出核心产品的途径，这样就可以先发布部分功能给客户，对客户起到镇静剂的作用。 | 至始至终开发者和客户纠缠在一起，直到完全版本出来；适合于软件需求不明确、设计方案有一定风险的软件项目。 |

（模型的图片详见 P16-18）





# 第二章 可行性研究



## 2.1 可行性研究的任务

> 可行性研究的目的，就是用最小的代价在尽可能短的时间内确定问题是否能过解决。

> 可行性研究最根本的任务是对以后的行动方针提出建议。

- 首先需要分析和澄清问题定义
- 在澄清了问题定义之后，分析员应该导出系统的逻辑模型。然后从系统逻辑模型出发，探索若干种可供选择的主要解法(即系统实现方案)。对每种解法都应该仔细研究它的可行性。
    - 技术可行性：使用现有的技术能实现这个系统吗
    - 经济可行性：这个系统的经济效益能超过它的开发成本吗
    - 操作可行性：系统的操作方式在这个用户组织内行得通吗
- 必要时还应该从法律、社会效益等更广泛的方面研究每种解法的可能性。



## 2.2 可行性研究过程

- 复查系统规模和目标
- 研究目前正在使用的系统
- 导出新系统的高层逻辑模型
- 进一步定义问题
- 导出和评价供选择的解法
- 推荐行动方针
- 草拟开发计划
- 书写文档提交审查。



## 2.4 数据流图



### 2.4.1 数据流图的概念

> 数据流图(DFD)是一种图形化技术，它描绘信息流和数据从输入移动到输出的过程中所经受的变换。

在数据流图中没有任何具体的物理部件，它只是描绘数据在软件中流动和被处理的逻辑过程。

数据流图是系统逻辑功能的图形表示。



### 2.4.2 数据流图的符号

> 数据流与程序流程图中用箭头表示的控制流有本质不同，千万不要混淆。在数据流图中应该描绘所有可能的数据流向，而不应该描绘出现某个数据流的条件。

（图见 P41）

![查看源图像](https://gss0.baidu.com/-4o3dSag_xI4khGko9WTAnF6hhy/zhidao/wh%3D600%2C800/sign=2b177926c53d70cf4cafa20bc8ecfd38/00e93901213fb80e2fc54ac83ad12f2eb938949c.jpg)



### 2.4.3 数据流图的用途

- 画数据流图的基本目的是利用它作为交流信息的工具。

```
数据流图应该分层，并且在把功能级数据流图细化后得到的处理超过9个时，应该采用画分图的办法，也就是把每个主要功能都细化为一张数据流分图，而原有的功能级数据流图用来描绘系统的整体逻辑概貌。
```

- 数据流图的另一个主要用途是作为分析和设计的工具。

```
当用数据流图辅助物理系统的设计时，以图中不同处理的定时要求为指南，能够在数据流图上画出许多组自动化边界，每组自动化边界可能意味着一个不同的物理系统，因此可以根据系统的逻辑模型考虑系统的物理实现。
```





## 2.5 数据字典



### 2.5.1 数据字典的定义

> 数据字典是关于数据的信息的集合，也就是对数据流图中包含的所有元素的定义的集合。



### 2.5.2 数据字典的内容

数据字典包含下列4类元素的定义：数据流；数据流分量(即数据元素)；数据存储；处理。



### 2.5.3 定义数据的方法

> 数据字典中的定义就是对数据自顶向下的分解。

由数据元素组成数据的方式只有下述三种基本类型：

- 顺序，即以确定次序连接两个或多个分量
- 选择，即从两个或多个可能的元素中选取一个
- 重复，即把指定的分量重复零次或多次
- 可选，即一个分量是可有可无的(重复零次或一次)。



### 2.5.4 数据字典的符号

- `=`意思是等价于(或定义为)
- `+`意思是和(即，连接两个分量)
- `[]`意思是或(即，从方括弧内列出的若干个分量中选择一个)，通常用“|”号隔开供选择的分量
- `{}`意思是重复(即，重复花括弧内的分量)
- `()`意思是可选(即，圆括弧里的分量可有可无)。



### 2.5.5 数据字典的练习 

![image-20211228184748440](软工复习.assets/image-20211228184748440.png)





# 第三章 需求分析



## 3.1 确定对系统的综合要求

- 功能需求：这方面的需求指定系统必须提供的服务；
- 性能需求：性能需求指定系统必须满足的定时约束或容量约束，通常包括速度（响应时间）、信息量速率、主存容量、磁盘容量、安全性等方面的需求；
- 可靠性和可用性需求：可靠性需求定量地指定系统的可靠性；
- 出错处理需求：这类需求说明系统对环境错误应该怎样响应；
- 接口需求：接口需求描述应用系统与它的环境通信的格式；
- 约束：设计约束或实现约束描述在设计或实现应用系统时应遵守的限制条件；
- 逆向需求：逆向需求说明软件系统不应该做什么；
- 将来可能提出的要求：应该明确地列出那些虽然不属于当前系统开发范畴，但是据分析将来很可能会提出来的要求。



## 3.2 访谈



### 3.2.1 正式访谈

正式访谈时，系统分析员将提出一些事先准备好的具体问题。

### 3.2.2 非正式访谈

在非正式访谈中，分析员将提出一些用户可以自由回答的开放性问题，以鼓励被访问人员说出自己的想法。



## 3.3 各种图的绘制

- 数据模型（ER图）
- 功能模型（数据流图）
- 行为模型（状态图）



## 3.4 联系



### 3.4.1 一对一

  \* 一个人对应一张身份证，一张身份证对应一个人

![img](https://img-blog.csdn.net/20180110152542236?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzE0NDI4Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

### 3.4.2 一对多

  \* 一个班级拥有多个学生，一个学生只能够属于某个班级

![img](https://img-blog.csdn.net/20180110153205823?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzE0NDI4Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

### 3.4.3 多对多

  \* 一个学生可以选修多门课程，一个课程可以被多个学生选修

![img](https://img-blog.csdn.net/20180110154604022?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzE0NDI4Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)



## 3.5 数据规范化

第一范式：每个属性值都必须是原子值，即仅仅是一个简单值而不含内部结构。

第二范式：满足第一范式条件，而且每个非关键字属性都由整个关键字决定（而不是由关键字的一部分来决定）。

第三范式：符合第二范式的条件，每个非关键字属性都仅由关键字决定，而且一个非关键字属性不能仅仅是对另一个非关键字属性的进一步描述（即一个非关键字属性值不依赖于另一个非关键字属性值）。

范式越高，冗余度越小，表越多，理解越困难。





# 第五章 总体设计

> 总体设计的目的就是回答“**概括地说，系统应该如何实现**”这个问题。



## 5.1 设计过程

- 设想供选择的方案；
- 选取合理的方案；
- 推荐最佳方案；
- 功能分解；
- 设计软件结构；
- 设计数据库；
- 制定测试计划
- 书写文档（包括系统说明，用户手册，测试计划，详细的实现计划，数据库设计结果）；
- 审查和复查。



## 5.2 设计原理



### 5.2.1 模块化

就是把程序划分成独立命名且可独立访问的模块，每个模块完成一个子功能，把这些模块集成起来构成一个整体，可以完成指定的功能满足用户的需求

### 5.2.2 抽象

抽象就是抽出事物的本质特性而暂时不考虑它们的细节。

### 5.2.3 逐步求精

为了能集中精力解决主要问题而尽量推迟对问题细节的考虑



### 5.2.4 耦合

> 耦合是对一个软件结构内不同模块之间互连程度的度量。耦合强弱取决于模块间接口的复杂程度，进入或访问一个模块的点，以及通过接口的数据。

**公共环境耦合（全局变量）**

当两个或多个模块通过一个公共数据环境相互作用时，它们之间的耦合称为公共环境耦合。



### 5.2.5 内聚

> 内聚标志着一个模块内各个元素彼此结合的紧密程度，它是信息隐藏和局部化概念的自然拓展。简单地说，理想内聚的模块只做一件事情。

- 低内聚
    - 偶然内聚：如果一个模块完成一组任务，这些任务彼此间即使有关系，关系也是很松散的
    - 逻辑内聚：如果一个模块完成的任务在逻辑上属于相同或相似的一类
    - 时间内聚：如果一个模块包含的任务必须在同一段时间内执行
- 高内聚
    - 顺序内聚：如果一个模块内的处理元素和同一个功能密切相关，而且这些处理必须顺序执行
    - 功能内聚：如果模块内所有处理元素属于一个整体，完成一个单一的功能



## 5.3 启发规则

- 改进软件结构提高模块独立性；
- 模块规模应该适中；
- 深度、宽度、扇出和扇入都应适当；
- 模块的作用域应该在控制域之内；
- 力争降低模块接口的复杂程度；
- 设计单入口单出口的模块；
- 模块功能应该可以预测。



## 5.4 层次图 P102





# 第六章 详细设计

>  详细设计阶段的**根本目标是确定应该怎样具体地实现所要求的系统**，也就是说，经过这个阶段的设计工作，应该得出对目标系统的精确描述，从而在编码阶段可以把这个描述直接翻译成用某种程序设计语言书写的程序。
>
> **代码质量由详细设计分析人决定的**



## 6.2 设计问题

- 系统响应时间；
- 用户帮助设施；
- 出错信息处理；
- 命令交互。

## 6.3 判定树 P129



## 6.5 程序复杂程度



### 6.5.1 McCabe 方法

McCabe方法根据程序控制流的复杂程度定量度量程序的复杂程度，这样度量出的结果称为程序的环形复杂度。



**计算环形复杂度**

1. 流图中线性无关的区域数等于环形复杂度
2. 流图G的环形复杂度 `V(G) = E - N + 2` ，E是边数，N是点数
3. 流图G的环形复杂度 `V(G) = P  + 1`，P是判定节点的数目

图见P138



**画流程图，转换**



### 6.5.2 Halstead方法

Halstead方法根据程序中运算符和操作数的总数来度量程序的复杂程度。



## 6.6 练习

P142 7

![image-20211229161457353](软工复习.assets/image-20211229161457353.png)
