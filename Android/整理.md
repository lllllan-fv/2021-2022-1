# 1 活动



## 1.1 活动的基本用法



### 1.1.1 活动的定义

- 继承 `AppCompatActivity`
- 重写 `onCreate(Bundle bundle)`

```java
public class MainActivity extends AppCompatActivity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
    }
}
```



### 1.1.2 活动的注册

> 所有的活动都要在 `AndroidManifest.xml` 中进行注册才能生效

```xml
<application android:...>
	<activity android:name=".MianActivity"></activity>
</application>
```



### 1.1.3 活动的启动

```java
Intent intent = new Intent(Intent.ACTION_DIAL);
// startActivity(intent);
// startActivityForResult(intent, 1);
```



## 1.2 Toast 的使用

```java
Toast.makeText(MainActivity.this, "hello world", Toast.LENGTH_SHORT).show;
```



## 1.3 Intent 及其作用

Intent——意图，它可以带有数据，在Android设备上的任何应用程序组件间相互作用，将不同组件连在一起的桥梁。

Intent作用：

- Intent最常用在启动新的Activity，不管是显式的（通过指定类来加载）还是隐式的（通过请求在一块数据上执行的动作）。
- Intent还可以用来广播消息，然后使用Broadcast Receiver来监听并响应这些Intent。
- 使用Intent来传播动作，比如通过我们的程序中打电话。



## 1.4 活动的生命周期



### 1.4.1生命周期方法

- `onCreate` 第一次被创建时候调用
- `onStart` 由不可见变为可见时候调用
- `onRecume` 应用与用户交互的状态，此时的活动位于返回栈的栈顶，并且出于运行状态
- `onPause` 系统准备去启动或者恢复其他活动时候调用
- `onStop` 在活动完全不可见时候调用。如果启动了一个对话框活动，`onPause`会被调用，而`onStop`不会
- `onDestroy` 活动被销毁之前调用
- `onRestart` 活动由停止状态变为运行状态之前调用

> **完整生存期**。活动在 `onCreate()` 方法和 `onDestroy()` 方法之间所经历的称为完整生存期。
>
> **可见生存期**。活动在 `onStart()` 方法和 `onStop()` 方法之间所经历的称为可见生存期。
>
> **前台生存期**。活动在 `onResume()` 方法和 `onPause()` 方法之间所经历的称为前台生存期



### 1.4.2 生命周期状态及其转换

- 运行状态。活动位于返回栈的栈顶
- 暂停状态。活动不位于返回栈的栈顶，但活动仍然可见
- 停止状态。活动不位于返回栈的栈顶，并且完全不可见
- 销毁状态。活动从返回栈中移除



### 1.4.3 生命周期方法的调用顺序

![查看源图像](https://static001.infoq.cn/resource/image/b3/2f/b3aafc355b5c238aebec742b24f6052f.png)



## 1.5 活动的启动模型

启动模式一共有4种。**standard、singleTop、singleTask**和**singleInstance**
 通过在 `AndroidManifest.xml` 中给`<activity>`标签指定`android:launchMode`属性来选择启动模式。



### 1.5.1 standard

活动的默认启动模式。在该模式下，每当启动一个新活动，它就会在返回栈中入栈，并处于栈顶的位置，并且，不管此活动是否已经存在于返回栈中，每次启动都会创建该活动的一个新实例。

![img](https://upload-images.jianshu.io/upload_images/1674835-cbec07958657c4a8.png?imageMogr2/auto-orient/strip|imageView2/2/w/611/format/webp)

### 1.5.2 singleTop

在启动活动时如果发现返回栈的栈顶已经是该活动，则认为可以直接使用它，不会再创建新的活动实例。

![img](https://upload-images.jianshu.io/upload_images/1674835-7e2417de609e171e.png?imageMogr2/auto-orient/strip|imageView2/2/w/613/format/webp)



### 1.5.3 singleTask

每次启动该活动时系统首先会在返回栈中检查是否存在该活动的实例，如果发现已经存在则直接使用该实例，并把在这个活动之上的所有活动统统出栈，如果没有发现就会创建一个新的活动实例。

![img](https://upload-images.jianshu.io/upload_images/1674835-dcef4bb069cc5d6f.png?imageMogr2/auto-orient/strip|imageView2/2/w/650/format/webp)



### 1.5.4 singleInstance

活动会启用一个新的返回栈来管理这个活动(其实如果singleTask模式指定了不同的taskAffinity，也会启动一个新的返回栈)。

![img](https://upload-images.jianshu.io/upload_images/1674835-7cf53bd4d1af899b.png?imageMogr2/auto-orient/strip|imageView2/2/w/746/format/webp)



## 1.6 活动之间的数据传递



### 1.6.1 向下一个活动传递数据

```java
button.setOnClickListener(new View.OnClickListener){
    @Override
    public void onClick(View view) {
        Intent intent = new Intent(MainActivity.this, SecondActivity.class);
       	intent.putExtra("data", "hello world");
        startActivity(intent);
    }
}
```

```java
Intent intent = getIntent();
String data = intent.getStringExtra("data");
```



### 1.6.2 返回数据给上一个活动

```java
button.setOnClickListener(new View.OnClickListener){
    @Override
    public void onClick(View view) {
        Intent intent = new Intent(MainActivity.this, SecondActivity.class); 
        startActivityForResult(intent, 1);
    }
}
```

```java
button.setOnClickListener(new View.OnClickListener){
    @Override
    public void onClick(View view) {
        Intent intent = new Intent(); 
        intent.putExtra("data", "return hello world");
        setResult(RESULT_OK, intent);
        finish();
    }
}
```

